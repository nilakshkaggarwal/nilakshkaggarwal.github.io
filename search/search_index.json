{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"IBPL Quick Reference Guide This guide has been designed to minimise the search time for the required for IBPL Queries as well as keeping in mind the needs for new users Headers Introduction: This section contains basic introduction about IBPL and its some basic syntax. It is must read for new users Terminology: This section briefly describe the terms frequently used in Graphcube Server","title":"Home"},{"location":"#ibpl-quick-reference-guide","text":"This guide has been designed to minimise the search time for the required for IBPL Queries as well as keeping in mind the needs for new users Headers Introduction: This section contains basic introduction about IBPL and its some basic syntax. It is must read for new users Terminology: This section briefly describe the terms frequently used in Graphcube Server","title":"IBPL Quick Reference Guide"},{"location":"Operation/Arithmetic/","text":"Arithmetic Operators The binary arithmetic operators supported in IBPL include: addition (+), subtraction (-), multiplication (*), division (/), power (^). They each accept two numeric values as input and return a numeric value. Addition The addition operator produces the sum of numeric operands or string concatenation.The Addition Operator is the plus sign (+) Example: 5 + 3 result = 8 Example: Measure.[UnitPrice] + 1000 result = one thousand added to unit price Subtraction The subtraction operator subtracts the two operands, producing their difference.The Subtraction Operator is the minus sign (-) Example: 5 - 3 result = 2 Exampe: Measure.[UnitPrice] - 1000 result = one thousand is subtracted from unit price Example: Measure.[unit price] - Measure.[unit cost] result = difference between unit price and unit cost Note:while adding or subtracting measures, if a measure has a null value, then the result of the opeartion will be null. To avoid this, user should use the Coalesce() function to take the non null values. Multiplication The multiplication operator produces the product of the operands.The Multiplication Operator is the asterisk (*) Example: 5 * 3 result = 15 Example: Measure.[unit price] * 100 result = one hundred times unit price Example: Measure.[unit sold] * Measure.[unit price] result = product of unit sold and unit price Division The Division Operator is the asterisk (/). Example: 5 / 3 result = 1.6666666667 Example: Measure.[unit price] / 100 result = unit price divided by one hundred Example: Measure.[unit price] / Measure.[unit cost] result = ratio of unit price to unit cost Note:when dividing measures, if a measure has a null value, then the return value of the Division Operator will be null. Also, if the divisor is equal to zero, this will cause an error. To avoid this, you should use the if/then/else function to check whether the divisor is non-zero. Power The Power Operator is the caret symbol (^). It raises the first input to the power of the second input and returns the result as a number. Example: 5^3 result=125 Example: Measure.[unit price] ^ 2 result = unit price is squared Example: Measure.[unit price] ^ Measure.[unit cost] result = unit price raised to the power of unit cost String Operators Concatenation The Concatenation Operator is the plus sign (+). It is used to concatenate two strings. For example, \"Web\" + \"COD\" In this example, the two strings are combined and the return value is the single string \u201cWebCOD\u201d.","title":"Arithmetic"},{"location":"Operation/Arithmetic/#arithmetic-operators","text":"The binary arithmetic operators supported in IBPL include: addition (+), subtraction (-), multiplication (*), division (/), power (^). They each accept two numeric values as input and return a numeric value.","title":"Arithmetic Operators"},{"location":"Operation/Arithmetic/#addition","text":"The addition operator produces the sum of numeric operands or string concatenation.The Addition Operator is the plus sign (+) Example: 5 + 3 result = 8 Example: Measure.[UnitPrice] + 1000 result = one thousand added to unit price","title":"Addition"},{"location":"Operation/Arithmetic/#subtraction","text":"The subtraction operator subtracts the two operands, producing their difference.The Subtraction Operator is the minus sign (-) Example: 5 - 3 result = 2 Exampe: Measure.[UnitPrice] - 1000 result = one thousand is subtracted from unit price Example: Measure.[unit price] - Measure.[unit cost] result = difference between unit price and unit cost Note:while adding or subtracting measures, if a measure has a null value, then the result of the opeartion will be null. To avoid this, user should use the Coalesce() function to take the non null values.","title":"Subtraction"},{"location":"Operation/Arithmetic/#multiplication","text":"The multiplication operator produces the product of the operands.The Multiplication Operator is the asterisk (*) Example: 5 * 3 result = 15 Example: Measure.[unit price] * 100 result = one hundred times unit price Example: Measure.[unit sold] * Measure.[unit price] result = product of unit sold and unit price","title":"Multiplication"},{"location":"Operation/Arithmetic/#division","text":"The Division Operator is the asterisk (/). Example: 5 / 3 result = 1.6666666667 Example: Measure.[unit price] / 100 result = unit price divided by one hundred Example: Measure.[unit price] / Measure.[unit cost] result = ratio of unit price to unit cost Note:when dividing measures, if a measure has a null value, then the return value of the Division Operator will be null. Also, if the divisor is equal to zero, this will cause an error. To avoid this, you should use the if/then/else function to check whether the divisor is non-zero.","title":"Division"},{"location":"Operation/Arithmetic/#power","text":"The Power Operator is the caret symbol (^). It raises the first input to the power of the second input and returns the result as a number. Example: 5^3 result=125 Example: Measure.[unit price] ^ 2 result = unit price is squared Example: Measure.[unit price] ^ Measure.[unit cost] result = unit price raised to the power of unit cost","title":"Power"},{"location":"Operation/Arithmetic/#string-operators","text":"Concatenation The Concatenation Operator is the plus sign (+). It is used to concatenate two strings. For example, \"Web\" + \"COD\" In this example, the two strings are combined and the return value is the single string \u201cWebCOD\u201d.","title":"String Operators"},{"location":"top-level/Introduction/","text":"Introduction IBPL stands for \"Integrated Business Planning Language\". It is used to access and manipulate data and meta-data in the GraphCube engine (also known as LiveServer). The ibpl structure is broadly classified as Rules: In the Rules language, IBPL is used to create named sets, set active rules for measures, define procedures and plug-ins, and create security rules. There are multiple rules files contained in the tenant/Configuration database and managed through th econfiguration UI. They are read and executed as a part of the startup process. All these will be in the section of IBPL usages Commands: In the Command language, IBPL is used to execute commands and queries on the GraphCube engine. The command language is used after the GraphCube engine has been started. There are three main ways it can be used: Commands can be executed in an interactive manner through one of the available clients (IBPLPlus, Meru, HTML UI). Commands can also be contained in a script (text file) that is sent to GraphCube engine for execution by the IBPLPlus client Commands can be contained in action buttons that are executed by users in the HTML UI or Excel UI. This is more Command Oriented IBPL capabilities Querying data - Access data filtered and ordered as required for validation and verification. Usually the number of rows fetched will be few. If the number of rows is large one should transfer data using files for download. Modifying data - Update member data and run computations to update measures or edges. Usually large amount of measure data is updated. Actual scope statements are tested before converting them to active rules. Members, versions and measures could also be surgically manipulated. Transferring data - Upload or download member and measure data as files. Usually a large number of rows are fetched or uploaded. Querying model - Extract dimensions, measures, graphs etc. and their modelling details for the purposes of verification. Controlling access - create rules to grant or deny access to various types of data. Important Notations [\u2026] Square Bracket are used to contain names of Dimension, Attributes, Measures. It's usage is same as \"\u2026\" (Double Inverted Commas) . It is used to chain together functions and objects","title":"Introduction"},{"location":"top-level/Introduction/#introduction","text":"IBPL stands for \"Integrated Business Planning Language\". It is used to access and manipulate data and meta-data in the GraphCube engine (also known as LiveServer). The ibpl structure is broadly classified as Rules: In the Rules language, IBPL is used to create named sets, set active rules for measures, define procedures and plug-ins, and create security rules. There are multiple rules files contained in the tenant/Configuration database and managed through th econfiguration UI. They are read and executed as a part of the startup process. All these will be in the section of IBPL usages Commands: In the Command language, IBPL is used to execute commands and queries on the GraphCube engine. The command language is used after the GraphCube engine has been started. There are three main ways it can be used: Commands can be executed in an interactive manner through one of the available clients (IBPLPlus, Meru, HTML UI). Commands can also be contained in a script (text file) that is sent to GraphCube engine for execution by the IBPLPlus client Commands can be contained in action buttons that are executed by users in the HTML UI or Excel UI. This is more Command Oriented","title":"Introduction"},{"location":"top-level/Introduction/#ibpl-capabilities","text":"Querying data - Access data filtered and ordered as required for validation and verification. Usually the number of rows fetched will be few. If the number of rows is large one should transfer data using files for download. Modifying data - Update member data and run computations to update measures or edges. Usually large amount of measure data is updated. Actual scope statements are tested before converting them to active rules. Members, versions and measures could also be surgically manipulated. Transferring data - Upload or download member and measure data as files. Usually a large number of rows are fetched or uploaded. Querying model - Extract dimensions, measures, graphs etc. and their modelling details for the purposes of verification. Controlling access - create rules to grant or deny access to various types of data. Important Notations [\u2026] Square Bracket are used to contain names of Dimension, Attributes, Measures. It's usage is same as \"\u2026\" (Double Inverted Commas) . It is used to chain together functions and objects","title":"IBPL capabilities"},{"location":"top-level/terminology/","text":"Terminology Dimension Data Simply a dimension data is the data which is represented in the rows of the data sheet e.g. Name, Address, OrderIDs etc. dimension data is not involved in calculation instaed calculations are shown against it. The following terms are used to describe entities which holds dimension data. Dimensions A dimension is an entity such as \"Product\" or \"Customer\" that can be used to describe some facet of business planning data. For example, a sales forecast may be described using dimensions like Product, Sales Domain and Time, whereas a budget may be described using dimensions like Spend Domain and Time. A Product Dimension Conatins all data related to products Attribute and attribute property Attribute can either refer to an attribute of the dimension that defines a level in a hierarchy, and it is known as LevelAttribute. For e.g. Product Dimension stores attributes like ProductID, size, SKU, Classification, Category, SubCategory Attribute Properties are defined for members based on level. These have one to one relation with attribute members. For eg Each ProductID will have one image which no other ProductID would have. It is not compulsory to define properties for each and every attributes. In other words, a property like \"Image\" may be defined for members in the \"Product Name\" level, but not for \"Category\" or \"Sub-Category\" members. Another property, like \"Category Image\" may be defined for members in the \"Category\" level, but not members of other levels. Member As the name suggests a member is a specific instance (a member) of an attribute in a dimension. For example, 'FUR-CH-10000454' is a member under attribute ProductID in dimension Product. A member is also referred to as an AttributeMember. There are some default dimensions in o9 platform like: Version: As the name suggest it helps in the management of different version of data and to manage scenarios. There is always by default Version called CurrentWorkingView (CWV), which represent the plan of record. Scenarios are dynamic versions that are used to evaluate some scenario or perform some what-if analysis. Saved versions are snapshots of the CWV taken at some time in the past and cannot be edited.In the Version dimension, the Key is an integer. The value of zero is reserved for the CWV. A negative value for Key indicates that the version is a \u2018scenario\u2019 or \u2018what-if\u2019 version. A positive value for Key indicates that the version is an archived snapshot of the plan Dim plugin: Algorithm: Personnel:","title":"Terminology"},{"location":"top-level/terminology/#terminology","text":"","title":"Terminology"},{"location":"top-level/terminology/#dimension-data","text":"Simply a dimension data is the data which is represented in the rows of the data sheet e.g. Name, Address, OrderIDs etc. dimension data is not involved in calculation instaed calculations are shown against it. The following terms are used to describe entities which holds dimension data.","title":"Dimension Data"},{"location":"top-level/terminology/#dimensions","text":"A dimension is an entity such as \"Product\" or \"Customer\" that can be used to describe some facet of business planning data. For example, a sales forecast may be described using dimensions like Product, Sales Domain and Time, whereas a budget may be described using dimensions like Spend Domain and Time. A Product Dimension Conatins all data related to products","title":"Dimensions"},{"location":"top-level/terminology/#attribute-and-attribute-property","text":"Attribute can either refer to an attribute of the dimension that defines a level in a hierarchy, and it is known as LevelAttribute. For e.g. Product Dimension stores attributes like ProductID, size, SKU, Classification, Category, SubCategory Attribute Properties are defined for members based on level. These have one to one relation with attribute members. For eg Each ProductID will have one image which no other ProductID would have. It is not compulsory to define properties for each and every attributes. In other words, a property like \"Image\" may be defined for members in the \"Product Name\" level, but not for \"Category\" or \"Sub-Category\" members. Another property, like \"Category Image\" may be defined for members in the \"Category\" level, but not members of other levels.","title":"Attribute and attribute property"},{"location":"top-level/terminology/#member","text":"As the name suggests a member is a specific instance (a member) of an attribute in a dimension. For example, 'FUR-CH-10000454' is a member under attribute ProductID in dimension Product. A member is also referred to as an AttributeMember. There are some default dimensions in o9 platform like: Version: As the name suggest it helps in the management of different version of data and to manage scenarios. There is always by default Version called CurrentWorkingView (CWV), which represent the plan of record. Scenarios are dynamic versions that are used to evaluate some scenario or perform some what-if analysis. Saved versions are snapshots of the CWV taken at some time in the past and cannot be edited.In the Version dimension, the Key is an integer. The value of zero is reserved for the CWV. A negative value for Key indicates that the version is a \u2018scenario\u2019 or \u2018what-if\u2019 version. A positive value for Key indicates that the version is an archived snapshot of the plan Dim plugin: Algorithm: Personnel:","title":"Member"},{"location":"transforming-data/querying/","text":"Querying Select Example Select ( [ Product ].[ ProductID ] * [ Time ].[ Week ] * { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) where { Version .[ Version Name ]. Filter ( # . Key == 0 ) } orderby Measure .[ UnitPrice ] desc limit 6 ; Result: ProductID Week UnitSold UnitPrice TEC-AC-10001767 5 3 137,076 TEC-MA-10001148 3 2 123,543 TEC-MA-10000864 4 4 102,922 FUR-FU-10002505 2 1 98,015 TEC-AC-10004659 1 3 93,606 FUR-FU-10003773 3 9 93,051 The code contains following parts [Product].[ProductID] * [Time].[Week] * : It defines scope or granularity against which measure data has to be represented. In the report first column will have all the ProductID and second column will have the Week corresponding to it. All the attributes need to be appended by * They are written as [Dimension].[Attribute] Version in granularity in necessary otherwise 0 rows will be shown. Here it is used in where clause. {Measure.[UnitSold], Measure.[UnitPrice]} : It defines the measures which are represented against above defined scope. It will show the UnitPrice and UnitSold for the particular ProductID and in particular week. Measure. has to be prepended before measure names and measure names should be in Square Bracket where {Version.[Version Name].Filter(#.Key == 0)} : where command is used to limit the scope of selection. Here only selection is for only those Version whoose [Version Name] MemberKey is 0 (CurrentWorkingView). Key is the unique no. assigned to every attributemember. Other than Key, Name can be used to find the exact attributemember if the key is unknown Filter This command filters the data according to query specified in the paratheses() # is used here to represent Version.[Version Name] on which filter query has been applied orderby Measure.[UnitPrice] desc : It is used to order the list by UnitPrice. Generally orderby orders the list in ascending order. desc has to be appended if list is required in descending order limit 6 : It is used get only 6 rows of the result. top and bottom can be used instead of limit to display top and bottom n rows respectively. This is the basic statement which is used to Query data and one complete select statement ends with ; . So it doesn't matter if it is written in one single line or multiple lines. (1) & (2) are compulsary (3),(4) and (5) are optional. Select ([ Product ].[ ProductID ] * [ Time ].[ Week ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column where { Version .[ Version Name ]. Filter ( # . Key == 0 ) } ; OR Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column ; This code is equivalent to earlier code with just parts (1), (2) and (3). Current usage is shown in the syntax but it is more vast. And how to convert to one to another. SYNTAX : Select ( < rows > ) on row , ( { < columns > } ) on column ; SYNTAX : Select ( < rows >* { < columns > } ); Select () on row, () on column Basic Usage Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column ; Above example can also be written as Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ] * { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on row , () on column ; Dimension, Attribute Members select ( Customer .[ CustomerID ]) on row , () on column ; Result: All members of Attribute CustomerID are displayed CustomerID AA-10480 AD-10180 AG-10270 \u2026 97 more rows select ( Customer .[ CustomerID ] * Customer .[ CustomerName ] * Customer .[ City ] * Customer .[ State ]) on row , () on column ; Result: CustomerID CustomerName City State AA-10480 Atish Awasthi Bareilly Uttar Pradesh AD-10180 Ashish Dungdung Pune Maharashtra AG-10270 Akash Gowtham Tirupati Andhra Pradesh AM-10360 Aarush Mittal Valsad Gujarat \u2026 96 more rows","title":"Querying"},{"location":"transforming-data/querying/#querying","text":"","title":"Querying"},{"location":"transforming-data/querying/#select","text":"Example Select ( [ Product ].[ ProductID ] * [ Time ].[ Week ] * { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) where { Version .[ Version Name ]. Filter ( # . Key == 0 ) } orderby Measure .[ UnitPrice ] desc limit 6 ; Result: ProductID Week UnitSold UnitPrice TEC-AC-10001767 5 3 137,076 TEC-MA-10001148 3 2 123,543 TEC-MA-10000864 4 4 102,922 FUR-FU-10002505 2 1 98,015 TEC-AC-10004659 1 3 93,606 FUR-FU-10003773 3 9 93,051 The code contains following parts [Product].[ProductID] * [Time].[Week] * : It defines scope or granularity against which measure data has to be represented. In the report first column will have all the ProductID and second column will have the Week corresponding to it. All the attributes need to be appended by * They are written as [Dimension].[Attribute] Version in granularity in necessary otherwise 0 rows will be shown. Here it is used in where clause. {Measure.[UnitSold], Measure.[UnitPrice]} : It defines the measures which are represented against above defined scope. It will show the UnitPrice and UnitSold for the particular ProductID and in particular week. Measure. has to be prepended before measure names and measure names should be in Square Bracket where {Version.[Version Name].Filter(#.Key == 0)} : where command is used to limit the scope of selection. Here only selection is for only those Version whoose [Version Name] MemberKey is 0 (CurrentWorkingView). Key is the unique no. assigned to every attributemember. Other than Key, Name can be used to find the exact attributemember if the key is unknown Filter This command filters the data according to query specified in the paratheses() # is used here to represent Version.[Version Name] on which filter query has been applied orderby Measure.[UnitPrice] desc : It is used to order the list by UnitPrice. Generally orderby orders the list in ascending order. desc has to be appended if list is required in descending order limit 6 : It is used get only 6 rows of the result. top and bottom can be used instead of limit to display top and bottom n rows respectively. This is the basic statement which is used to Query data and one complete select statement ends with ; . So it doesn't matter if it is written in one single line or multiple lines. (1) & (2) are compulsary (3),(4) and (5) are optional. Select ([ Product ].[ ProductID ] * [ Time ].[ Week ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column where { Version .[ Version Name ]. Filter ( # . Key == 0 ) } ; OR Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column ; This code is equivalent to earlier code with just parts (1), (2) and (3). Current usage is shown in the syntax but it is more vast. And how to convert to one to another. SYNTAX : Select ( < rows > ) on row , ( { < columns > } ) on column ; SYNTAX : Select ( < rows >* { < columns > } );","title":"Select"},{"location":"transforming-data/querying/#select-on-row-on-column","text":"","title":"Select () on row, () on column"},{"location":"transforming-data/querying/#basic-usage","text":"Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ]) on row , ( { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on column ; Above example can also be written as Select ([ Product ].[ ProductID ] * [ Time ].[ Week ] * Version .[ Version Name ] * { Measure .[ UnitSold ], Measure .[ UnitPrice ] } ) on row , () on column ;","title":"Basic Usage"},{"location":"transforming-data/querying/#dimension-attribute-members","text":"select ( Customer .[ CustomerID ]) on row , () on column ; Result: All members of Attribute CustomerID are displayed CustomerID AA-10480 AD-10180 AG-10270 \u2026 97 more rows select ( Customer .[ CustomerID ] * Customer .[ CustomerName ] * Customer .[ City ] * Customer .[ State ]) on row , () on column ; Result: CustomerID CustomerName City State AA-10480 Atish Awasthi Bareilly Uttar Pradesh AD-10180 Ashish Dungdung Pune Maharashtra AG-10270 Akash Gowtham Tirupati Andhra Pradesh AM-10360 Aarush Mittal Valsad Gujarat \u2026 96 more rows","title":"Dimension, Attribute Members"}]}